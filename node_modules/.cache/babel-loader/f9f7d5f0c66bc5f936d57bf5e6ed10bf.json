{"ast":null,"code":"\"use client\";\n\nimport _slicedToArray from \"/Users/cdmstudent/Documents/GitHub/DDC_Current/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/Users/cdmstudent/Documents/GitHub/DDC_Current/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _objectWithoutProperties from \"/Users/cdmstudent/Documents/GitHub/DDC_Current/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"/Users/cdmstudent/Documents/GitHub/DDC_Current/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/cdmstudent/Documents/GitHub/DDC_Current/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/cdmstudent/Documents/GitHub/DDC_Current/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/cdmstudent/Documents/GitHub/DDC_Current/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/cdmstudent/Documents/GitHub/DDC_Current/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/cdmstudent/Documents/GitHub/DDC_Current/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/InView.tsx\nimport * as React from \"react\";\n\n// src/observe.ts\nvar observerMap = /* @__PURE__ */new Map();\nvar RootIds = /* @__PURE__ */new WeakMap();\nvar rootId = 0;\nvar unsupportedValue = void 0;\nfunction defaultFallbackInView(inView) {\n  unsupportedValue = inView;\n}\nfunction getRootId(root) {\n  if (!root) return \"0\";\n  if (RootIds.has(root)) return RootIds.get(root);\n  rootId += 1;\n  RootIds.set(root, rootId.toString());\n  return RootIds.get(root);\n}\nfunction optionsToId(options) {\n  return Object.keys(options).sort().filter(function (key) {\n    return options[key] !== void 0;\n  }).map(function (key) {\n    return \"\".concat(key, \"_\").concat(key === \"root\" ? getRootId(options.root) : options[key]);\n  }).toString();\n}\nfunction createObserver(options) {\n  var id = optionsToId(options);\n  var instance = observerMap.get(id);\n  if (!instance) {\n    var elements = /* @__PURE__ */new Map();\n    var thresholds;\n    var observer = new IntersectionObserver(function (entries) {\n      entries.forEach(function (entry) {\n        var _a;\n        var inView = entry.isIntersecting && thresholds.some(function (threshold) {\n          return entry.intersectionRatio >= threshold;\n        });\n        if (options.trackVisibility && typeof entry.isVisible === \"undefined\") {\n          entry.isVisible = inView;\n        }\n        (_a = elements.get(entry.target)) == null ? void 0 : _a.forEach(function (callback) {\n          callback(inView, entry);\n        });\n      });\n    }, options);\n    thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);\n    instance = {\n      id: id,\n      observer: observer,\n      elements: elements\n    };\n    observerMap.set(id, instance);\n  }\n  return instance;\n}\nfunction observe(element, callback) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var fallbackInView = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : unsupportedValue;\n  if (typeof window.IntersectionObserver === \"undefined\" && fallbackInView !== void 0) {\n    var bounds = element.getBoundingClientRect();\n    callback(fallbackInView, {\n      isIntersecting: fallbackInView,\n      target: element,\n      intersectionRatio: typeof options.threshold === \"number\" ? options.threshold : 0,\n      time: 0,\n      boundingClientRect: bounds,\n      intersectionRect: bounds,\n      rootBounds: bounds\n    });\n    return function () {};\n  }\n  var _createObserver = createObserver(options),\n    id = _createObserver.id,\n    observer = _createObserver.observer,\n    elements = _createObserver.elements;\n  var callbacks = elements.get(element) || [];\n  if (!elements.has(element)) {\n    elements.set(element, callbacks);\n  }\n  callbacks.push(callback);\n  observer.observe(element);\n  return function unobserve() {\n    callbacks.splice(callbacks.indexOf(callback), 1);\n    if (callbacks.length === 0) {\n      elements.delete(element);\n      observer.unobserve(element);\n    }\n    if (elements.size === 0) {\n      observer.disconnect();\n      observerMap.delete(id);\n    }\n  };\n}\n\n// src/InView.tsx\nfunction isPlainChildren(props) {\n  return typeof props.children !== \"function\";\n}\nvar InView = /*#__PURE__*/function (_React$Component) {\n  _inherits(InView, _React$Component);\n  function InView(props) {\n    var _this;\n    _classCallCheck(this, InView);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(InView).call(this, props));\n    __publicField(_assertThisInitialized(_assertThisInitialized(_this)), \"node\", null);\n    __publicField(_assertThisInitialized(_assertThisInitialized(_this)), \"_unobserveCb\", null);\n    __publicField(_assertThisInitialized(_assertThisInitialized(_this)), \"handleNode\", function (node) {\n      if (_this.node) {\n        _this.unobserve();\n        if (!node && !_this.props.triggerOnce && !_this.props.skip) {\n          _this.setState({\n            inView: !!_this.props.initialInView,\n            entry: void 0\n          });\n        }\n      }\n      _this.node = node ? node : null;\n      _this.observeNode();\n    });\n    __publicField(_assertThisInitialized(_assertThisInitialized(_this)), \"handleChange\", function (inView, entry) {\n      if (inView && _this.props.triggerOnce) {\n        _this.unobserve();\n      }\n      if (!isPlainChildren(_this.props)) {\n        _this.setState({\n          inView: inView,\n          entry: entry\n        });\n      }\n      if (_this.props.onChange) {\n        _this.props.onChange(inView, entry);\n      }\n    });\n    _this.state = {\n      inView: !!props.initialInView,\n      entry: void 0\n    };\n    return _this;\n  }\n  _createClass(InView, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold || prevProps.skip !== this.props.skip || prevProps.trackVisibility !== this.props.trackVisibility || prevProps.delay !== this.props.delay) {\n        this.unobserve();\n        this.observeNode();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.unobserve();\n      this.node = null;\n    }\n  }, {\n    key: \"observeNode\",\n    value: function observeNode() {\n      if (!this.node || this.props.skip) return;\n      var _this$props = this.props,\n        threshold = _this$props.threshold,\n        root = _this$props.root,\n        rootMargin = _this$props.rootMargin,\n        trackVisibility = _this$props.trackVisibility,\n        delay = _this$props.delay,\n        fallbackInView = _this$props.fallbackInView;\n      this._unobserveCb = observe(this.node, this.handleChange, {\n        threshold: threshold,\n        root: root,\n        rootMargin: rootMargin,\n        // @ts-ignore\n        trackVisibility: trackVisibility,\n        // @ts-ignore\n        delay: delay\n      }, fallbackInView);\n    }\n  }, {\n    key: \"unobserve\",\n    value: function unobserve() {\n      if (this._unobserveCb) {\n        this._unobserveCb();\n        this._unobserveCb = null;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      if (typeof children === \"function\") {\n        var _this$state = this.state,\n          inView = _this$state.inView,\n          entry = _this$state.entry;\n        return children({\n          inView: inView,\n          entry: entry,\n          ref: this.handleNode\n        });\n      }\n      var _this$props2 = this.props,\n        as = _this$props2.as,\n        triggerOnce = _this$props2.triggerOnce,\n        threshold = _this$props2.threshold,\n        root = _this$props2.root,\n        rootMargin = _this$props2.rootMargin,\n        onChange = _this$props2.onChange,\n        skip = _this$props2.skip,\n        trackVisibility = _this$props2.trackVisibility,\n        delay = _this$props2.delay,\n        initialInView = _this$props2.initialInView,\n        fallbackInView = _this$props2.fallbackInView,\n        props = _objectWithoutProperties(_this$props2, [\"as\", \"triggerOnce\", \"threshold\", \"root\", \"rootMargin\", \"onChange\", \"skip\", \"trackVisibility\", \"delay\", \"initialInView\", \"fallbackInView\"]);\n      return React.createElement(as || \"div\", _objectSpread({\n        ref: this.handleNode\n      }, props), children);\n    }\n  }]);\n  return InView;\n}(React.Component);\n\n// src/useInView.tsx\nimport * as React2 from \"react\";\nfunction useInView() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    threshold = _ref.threshold,\n    delay = _ref.delay,\n    trackVisibility = _ref.trackVisibility,\n    rootMargin = _ref.rootMargin,\n    root = _ref.root,\n    triggerOnce = _ref.triggerOnce,\n    skip = _ref.skip,\n    initialInView = _ref.initialInView,\n    fallbackInView = _ref.fallbackInView,\n    onChange = _ref.onChange;\n  var _a;\n  var _React2$useState = React2.useState(null),\n    _React2$useState2 = _slicedToArray(_React2$useState, 2),\n    ref = _React2$useState2[0],\n    setRef = _React2$useState2[1];\n  var callback = React2.useRef();\n  var _React2$useState3 = React2.useState({\n      inView: !!initialInView,\n      entry: void 0\n    }),\n    _React2$useState4 = _slicedToArray(_React2$useState3, 2),\n    state = _React2$useState4[0],\n    setState = _React2$useState4[1];\n  callback.current = onChange;\n  React2.useEffect(function () {\n    if (skip || !ref) return;\n    var unobserve;\n    unobserve = observe(ref, function (inView, entry) {\n      setState({\n        inView: inView,\n        entry: entry\n      });\n      if (callback.current) callback.current(inView, entry);\n      if (entry.isIntersecting && triggerOnce && unobserve) {\n        unobserve();\n        unobserve = void 0;\n      }\n    }, {\n      root: root,\n      rootMargin: rootMargin,\n      threshold: threshold,\n      // @ts-ignore\n      trackVisibility: trackVisibility,\n      // @ts-ignore\n      delay: delay\n    }, fallbackInView);\n    return function () {\n      if (unobserve) {\n        unobserve();\n      }\n    };\n  },\n  // We break the rule here, because we aren't including the actual `threshold` variable\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [\n  // If the threshold is an array, convert it to a string, so it won't change between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  Array.isArray(threshold) ? threshold.toString() : threshold, ref, root, rootMargin, triggerOnce, skip, trackVisibility, fallbackInView, delay]);\n  var entryTarget = (_a = state.entry) == null ? void 0 : _a.target;\n  var previousEntryTarget = React2.useRef();\n  if (!ref && entryTarget && !triggerOnce && !skip && previousEntryTarget.current !== entryTarget) {\n    previousEntryTarget.current = entryTarget;\n    setState({\n      inView: !!initialInView,\n      entry: void 0\n    });\n  }\n  var result = [setRef, state.inView, state.entry];\n  result.ref = result[0];\n  result.inView = result[1];\n  result.entry = result[2];\n  return result;\n}\nexport { InView, defaultFallbackInView, observe, useInView };","map":null,"metadata":{},"sourceType":"module"}